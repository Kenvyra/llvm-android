From 0f3e272c5ad139bc18a1924a759f7513b1fb7f43 Mon Sep 17 00:00:00 2001
From: Rafael Auler <rafaelauler@fb.com>
Date: Sat, 17 Sep 2022 19:07:33 +0200
Subject: [PATCH] [BOLT] Add pass to fix ambiguous memory references

---
 bolt/include/bolt/Passes/ValidateMemRefs.h    |  43 ++++++++
 bolt/lib/Core/BinaryEmitter.cpp               |   8 +-
 bolt/lib/Passes/CMakeLists.txt                |   1 +
 bolt/lib/Passes/ValidateMemRefs.cpp           | 104 ++++++++++++++++++
 bolt/lib/Rewrite/BinaryPassManager.cpp        |   9 +-
 .../runtime/X86/jt-symbol-disambiguation-2.s  |  91 +++++++++++++++
 .../runtime/X86/jt-symbol-disambiguation.s    |  91 +++++++++++++++
 7 files changed, 343 insertions(+), 4 deletions(-)
 create mode 100644 bolt/include/bolt/Passes/ValidateMemRefs.h
 create mode 100644 bolt/lib/Passes/ValidateMemRefs.cpp
 create mode 100644 bolt/test/runtime/X86/jt-symbol-disambiguation-2.s
 create mode 100644 bolt/test/runtime/X86/jt-symbol-disambiguation.s

diff --git a/bolt/include/bolt/Passes/ValidateMemRefs.h b/bolt/include/bolt/Passes/ValidateMemRefs.h
new file mode 100644
index 000000000000..5c0fb74d990a
--- /dev/null
+++ b/bolt/include/bolt/Passes/ValidateMemRefs.h
@@ -0,0 +1,43 @@
+//===- bolt/Passes/ValidateMemRefs.h ----------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef BOLT_PASSES_VALIDATEMEMREFS_H
+#define BOLT_PASSES_VALIDATEMEMREFS_H
+
+#include "bolt/Passes/BinaryPasses.h"
+
+namespace llvm {
+namespace bolt {
+
+/// Post processing to check for memory references that cause a symbol
+/// in data section to be ambiguous, requiring us to avoid moving that
+/// object or disambiguating such references. This is currently
+/// limited to fixing false references to the location of jump tables.
+///
+class ValidateMemRefs : public BinaryFunctionPass {
+public:
+  explicit ValidateMemRefs(const cl::opt<bool> &PrintPass)
+      : BinaryFunctionPass(PrintPass) {}
+
+  const char *getName() const override { return "validate-mem-refs"; }
+
+  void runOnFunctions(BinaryContext &BC) override;
+
+private:
+  bool checkAndFixJTReference(BinaryContext &BC, BinaryFunction &BF,
+                              MCInst &Inst, uint32_t OperandNum,
+                              const MCSymbol *Sym, uint64_t Offset);
+  void runOnFunction(BinaryFunction &BF);
+
+  static std::atomic<std::uint64_t> ReplacedReferences;
+};
+
+} // namespace bolt
+} // namespace llvm
+
+#endif
diff --git a/bolt/lib/Core/BinaryEmitter.cpp b/bolt/lib/Core/BinaryEmitter.cpp
index 98c994333d93..48a0dc1a589a 100644
--- a/bolt/lib/Core/BinaryEmitter.cpp
+++ b/bolt/lib/Core/BinaryEmitter.cpp
@@ -817,7 +817,13 @@ void BinaryEmitter::emitJumpTable(const JumpTable &JT, MCSection *HotSection,
           Streamer.switchSection(ColdSection);
         Streamer.emitValueToAlignment(JT.EntrySize);
       }
-      Streamer.emitLabel(LI->second);
+      // Emit all labels registered at this address - sync with global sym table
+      if (BinaryData *BD = BC.getBinaryDataByName(LI->second->getName())) {
+        for (MCSymbol *S : BD->getSymbols())
+          Streamer.emitLabel(S);
+      } else {
+        Streamer.emitLabel(LI->second);
+      }
       LastLabel = LI->second;
     }
     if (JT.Type == JumpTable::JTT_NORMAL) {
diff --git a/bolt/lib/Passes/CMakeLists.txt b/bolt/lib/Passes/CMakeLists.txt
index bb296263bb4e..8b0071c0a870 100644
--- a/bolt/lib/Passes/CMakeLists.txt
+++ b/bolt/lib/Passes/CMakeLists.txt
@@ -43,6 +43,7 @@ add_llvm_library(LLVMBOLTPasses
   TailDuplication.cpp
   ThreeWayBranch.cpp
   ValidateInternalCalls.cpp
+  ValidateMemRefs.cpp
   VeneerElimination.cpp
   RetpolineInsertion.cpp
 
diff --git a/bolt/lib/Passes/ValidateMemRefs.cpp b/bolt/lib/Passes/ValidateMemRefs.cpp
new file mode 100644
index 000000000000..c167f986ec8a
--- /dev/null
+++ b/bolt/lib/Passes/ValidateMemRefs.cpp
@@ -0,0 +1,104 @@
+//===- bolt/Passes/ValidateMemRefs.cpp ------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "bolt/Passes/ValidateMemRefs.h"
+
+#define DEBUG_TYPE "bolt-memrefs"
+
+namespace opts {
+extern llvm::cl::opt<llvm::bolt::JumpTableSupportLevel> JumpTables;
+}
+
+namespace llvm {
+namespace bolt {
+
+std::atomic<std::uint64_t> ValidateMemRefs::ReplacedReferences{0};
+
+bool ValidateMemRefs::checkAndFixJTReference(BinaryContext &BC,
+                                             BinaryFunction &BF, MCInst &Inst,
+                                             uint32_t OperandNum,
+                                             const MCSymbol *Sym,
+                                             uint64_t Offset) {
+  BinaryData *BD = BC.getBinaryDataByName(Sym->getName());
+  if (!BD)
+    return false;
+
+  const uint64_t TargetAddress = BD->getAddress() + Offset;
+  JumpTable *JT = BC.getJumpTableContainingAddress(TargetAddress);
+  if (!JT)
+    return false;
+
+  const bool IsLegitAccess = llvm::any_of(
+      JT->Parents, [&](const BinaryFunction *Parent) { return Parent == &BF; });
+  if (IsLegitAccess)
+    return true;
+
+  // Accessing a jump table in another function. This is not a
+  // legitimate jump table access, we need to replace the reference to
+  // the jump table label with a regular rodata reference. Get a
+  // non-JT reference by fetching the symbol 1 byte before the JT
+  // label.
+  MCSymbol *NewSym = BC.getOrCreateGlobalSymbol(TargetAddress - 1, "DATAat");
+  BC.MIB->setOperandToSymbolRef(Inst, OperandNum, NewSym, 1, &*BC.Ctx, 0);
+  LLVM_DEBUG(dbgs() << "Replaced reference @" << BF.getPrintName() << " from "
+                    << BD->getName() << " to " << NewSym->getName()
+                    << " + 1\n");
+  ++ReplacedReferences;
+  return true;
+}
+
+void ValidateMemRefs::runOnFunction(BinaryFunction &BF) {
+  BinaryContext &BC = BF.getBinaryContext();
+  MCPlusBuilder *MIB = BC.MIB.get();
+
+  for (BinaryBasicBlock *BB : BF.getLayout().blocks()) {
+    for (MCInst &Inst : *BB) {
+      for (int I = 0, E = MCPlus::getNumPrimeOperands(Inst); I != E; ++I) {
+        const MCOperand &Operand = Inst.getOperand(I);
+        if (!Operand.isExpr())
+          continue;
+
+        const MCSymbol *Sym;
+        uint64_t Offset;
+        std::tie(Sym, Offset) = MIB->getTargetSymbolInfo(Operand.getExpr());
+        if (!Sym)
+          continue;
+
+        checkAndFixJTReference(BC, BF, Inst, I, Sym, Offset);
+      }
+    }
+  }
+}
+
+void ValidateMemRefs::runOnFunctions(BinaryContext &BC) {
+  if (!BC.isX86())
+    return;
+
+  // Skip validation if not moving JT
+  if (opts::JumpTables != JTS_MOVE)
+    return;
+
+  LLVM_DEBUG(dbgs() << "BOLT-DEBUG: Starting memrefs validation pass\n");
+  for (auto &BFI : BC.getBinaryFunctions()) {
+    BinaryFunction &Function = BFI.second;
+    if (Function.isIgnored())
+      continue;
+
+    runOnFunction(Function);
+  }
+  LLVM_DEBUG(dbgs() << "BOLT-DEBUG: memrefs validation is concluded\n");
+
+  if (!ReplacedReferences)
+    return;
+
+  outs() << "BOLT-INFO: validate-mem-refs updated " << ReplacedReferences
+         << " object references.\n";
+}
+
+} // namespace bolt
+} // namespace llvm
diff --git a/bolt/lib/Rewrite/BinaryPassManager.cpp b/bolt/lib/Rewrite/BinaryPassManager.cpp
index dff93b9a91a0..85b49a29c807 100644
--- a/bolt/lib/Rewrite/BinaryPassManager.cpp
+++ b/bolt/lib/Rewrite/BinaryPassManager.cpp
@@ -31,6 +31,7 @@
 #include "bolt/Passes/TailDuplication.h"
 #include "bolt/Passes/ThreeWayBranch.h"
 #include "bolt/Passes/ValidateInternalCalls.h"
+#include "bolt/Passes/ValidateMemRefs.h"
 #include "bolt/Passes/VeneerElimination.h"
 #include "bolt/Utils/CommandLineOpts.h"
 #include "llvm/Support/FormatVariadic.h"
@@ -317,9 +318,6 @@ void BinaryFunctionPassManager::runAllPasses(BinaryContext &BC) {
     Manager.registerPass(
         std::make_unique<VeneerElimination>(PrintVeneerElimination));
 
-  if (opts::Instrument)
-    Manager.registerPass(std::make_unique<Instrumentation>(NeverPrint));
-
   // Here we manage dependencies/order manually, since passes are run in the
   // order they're registered.
 
@@ -331,6 +329,11 @@ void BinaryFunctionPassManager::runAllPasses(BinaryContext &BC) {
 
   Manager.registerPass(std::make_unique<ValidateInternalCalls>(NeverPrint));
 
+  Manager.registerPass(std::make_unique<ValidateMemRefs>(NeverPrint));
+
+  if (opts::Instrument)
+    Manager.registerPass(std::make_unique<Instrumentation>(NeverPrint));
+
   Manager.registerPass(std::make_unique<ShortenInstructions>(NeverPrint));
 
   Manager.registerPass(std::make_unique<RemoveNops>(NeverPrint));
diff --git a/bolt/test/runtime/X86/jt-symbol-disambiguation-2.s b/bolt/test/runtime/X86/jt-symbol-disambiguation-2.s
new file mode 100644
index 000000000000..16a4f99be079
--- /dev/null
+++ b/bolt/test/runtime/X86/jt-symbol-disambiguation-2.s
@@ -0,0 +1,91 @@
+# In this test case, we reproduce the behavior seen in gcc where the
+# base address of a data object is decremented by some number and lands
+# inside a jump table from another function.
+
+# REQUIRES: system-linux
+
+# RUN: llvm-mc -filetype=obj -triple x86_64-unknown-unknown %s -o %t.o
+# RUN: llvm-strip --strip-unneeded %t.o
+# RUN: %clang %cflags -no-pie -nostartfiles -nostdlib -lc %t.o -o %t.exe -Wl,-q
+
+# RUN: llvm-bolt %t.exe -o %t.exe.bolt --relocs=1 --lite=0 \
+# RUN:   --reorder-blocks=reverse -jump-tables=move
+
+# RUN: %t.exe.bolt 1 2 3
+
+  .file "jt-symbol-disambiguation-2.s"
+  .text
+
+# ----
+# Func foo contains a jump table whose start is colocated with a
+# symbol marking the end of a data table
+# ----
+  .globl foo
+  .type foo, @function
+foo:
+  .cfi_startproc
+  xor    %rax,%rax
+  and    $0x3,%rdi
+  leaq   .JT1(%rip), %rax
+  movslq  (%rax, %rdi, 4), %rdi
+  addq   %rax, %rdi
+  jmpq   *%rdi
+.LBB1:
+  movl   $0x1,%eax
+  jmp    .LBB5
+.LBB2:
+  movl   $0x2,%eax
+  jmp    .LBB5
+.LBB3:
+  movl   $0x3,%eax
+  jmp    .LBB5
+.LBB4:
+  movl   $0x4,%eax
+.LBB5:
+  retq
+  .cfi_endproc
+  .size foo, .-foo
+
+# ----
+# Func _start scans an object with indexed access using %rax * 8 as an
+# index. However, %rax is known to be at least one, so the compiler
+# loads the pointer for the base address as object - 8 instead of just
+# object. That needs to be special cased by BOLT because there is a
+# jump table before that object, and BOLT can't move this JT since
+# it is not obvious whether this reference is to the JT itself or
+# to the object following it.
+# ----
+  .globl _start
+  .type _start, @function
+_start:
+  .cfi_startproc
+  movq   (%rsp), %rdi
+  callq foo
+  leaq   .object-8(%rip), %rsi  # indexed access base address
+  movq   $1, %rax               # start index
+.LBB6:
+  cmpq $4, %rax
+  je .LBB7
+  movq (%rsi,%rax,8), %rbx
+  incq %rax   # ++iterator
+  jmp .LBB6
+.LBB7:
+  xor   %rdi, %rdi
+  callq exit@PLT
+  .cfi_endproc
+  .size _start, .-_start
+
+# ----
+# Data section
+# ----
+  .section .rodata,"a",@progbits
+  .p2align 3
+.JT1:
+  .long .LBB1 - .JT1
+  .long .LBB2 - .JT1
+  .long .LBB3 - .JT1
+  .long .LBB4 - .JT1
+.object:
+  .quad 123
+  .quad 456
+  .quad 789
diff --git a/bolt/test/runtime/X86/jt-symbol-disambiguation.s b/bolt/test/runtime/X86/jt-symbol-disambiguation.s
new file mode 100644
index 000000000000..ea3b8934dd43
--- /dev/null
+++ b/bolt/test/runtime/X86/jt-symbol-disambiguation.s
@@ -0,0 +1,91 @@
+# In this test case, the symbol that represents the end of a table
+# in .rodata is being colocated with the start of a jump table from
+# another function, and BOLT moves that jump table. This should not
+# cause the symbol representing the end of the table to be moved as
+# well.
+# Bug reported in https://github.com/llvm/llvm-project/issues/55004
+
+# REQUIRES: system-linux
+
+# RUN: llvm-mc -filetype=obj -triple x86_64-unknown-unknown %s -o %t.o
+# RUN: llvm-strip --strip-unneeded %t.o
+# RUN: %clang %cflags -no-pie -nostartfiles -nostdlib -lc %t.o -o %t.exe -Wl,-q
+
+# RUN: llvm-bolt %t.exe -o %t.exe.bolt --relocs=1 --lite=0 \
+# RUN:   --reorder-blocks=reverse -jump-tables=move
+
+# RUN: %t.exe.bolt 1 2 3
+
+  .file "jt-symbol-disambiguation.s"
+  .text
+
+# ----
+# Func foo contains a jump table whose start is colocated with a
+# symbol marking the end of a data table
+# ----
+  .globl foo
+  .type foo, @function
+foo:
+  .cfi_startproc
+  xor    %rax,%rax
+  and    $0x3,%rdi
+  leaq   .JT1(%rip), %rax
+  movslq  (%rax, %rdi, 4), %rdi
+  addq   %rax, %rdi
+  jmpq   *%rdi
+.LBB1:
+  movl   $0x1,%eax
+  jmp    .LBB5
+.LBB2:
+  movl   $0x2,%eax
+  jmp    .LBB5
+.LBB3:
+  movl   $0x3,%eax
+  jmp    .LBB5
+.LBB4:
+  movl   $0x4,%eax
+.LBB5:
+  retq
+  .cfi_endproc
+  .size foo, .-foo
+
+# ----
+# Func _start scans a table using begin/end pointers. End pointer is colocated
+# with the start of a jump table of function foo. When that jump
+# table moves, end pointer in _start should not be affected.
+# ----
+  .globl _start
+  .type _start, @function
+_start:
+  .cfi_startproc
+  movq   (%rsp), %rdi
+  callq foo
+  leaq   .start_of_table(%rip), %rsi  # iterator
+  leaq   .end_of_table(%rip), %rdi    # iterator end
+.LBB6:
+  cmpq %rsi, %rdi
+  je .LBB7
+  movq (%rsi), %rbx
+  leaq 8(%rsi), %rsi            # ++iterator
+  jmp .LBB6
+.LBB7:
+  xor   %rdi, %rdi
+  callq exit@PLT
+  .cfi_endproc
+  .size _start, .-_start
+
+# ----
+# Data section
+# ----
+  .section .rodata,"a",@progbits
+  .p2align 3
+.start_of_table:
+  .quad 123
+  .quad 456
+  .quad 789
+.end_of_table:
+.JT1:
+  .long .LBB1 - .JT1
+  .long .LBB2 - .JT1
+  .long .LBB3 - .JT1
+  .long .LBB4 - .JT1
-- 
2.37.3

